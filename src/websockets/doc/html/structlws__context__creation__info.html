<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libwebsockets: lws_context_creation_info Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libwebsockets.org-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libwebsockets
   </div>
   <div id="projectbrief">Lightweight C library for HTML5 websockets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structlws__context__creation__info.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">lws_context_creation_info Struct Reference<div class="ingroups"><a class="el" href="group__context-and-vhost.html">Context-and-vhost</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="libwebsockets_8h_source.html">libwebsockets.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a424a5ce268d6903e42243be94487ab85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a424a5ce268d6903e42243be94487ab85">port</a></td></tr>
<tr class="separator:a424a5ce268d6903e42243be94487ab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75434932bb5df54665ea678eb8ac104a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a75434932bb5df54665ea678eb8ac104a">iface</a></td></tr>
<tr class="separator:a75434932bb5df54665ea678eb8ac104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb90ffb3e6d6db2db20f529d61bd9122"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#abb90ffb3e6d6db2db20f529d61bd9122">protocols</a></td></tr>
<tr class="separator:abb90ffb3e6d6db2db20f529d61bd9122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3d1155fc52f5048b481884f6fb947c"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__extension.html">lws_extension</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a4a3d1155fc52f5048b481884f6fb947c">extensions</a></td></tr>
<tr class="separator:a4a3d1155fc52f5048b481884f6fb947c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a75b7b259a3c3a5fbb4219a3f06c29"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac8a75b7b259a3c3a5fbb4219a3f06c29">token_limits</a></td></tr>
<tr class="separator:ac8a75b7b259a3c3a5fbb4219a3f06c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fb447be15c4fcb01d3285a6678ab54"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#af3fb447be15c4fcb01d3285a6678ab54">ssl_private_key_password</a></td></tr>
<tr class="separator:af3fb447be15c4fcb01d3285a6678ab54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62b0f0e8e402412ba5011d15c244103"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac62b0f0e8e402412ba5011d15c244103">ssl_cert_filepath</a></td></tr>
<tr class="separator:ac62b0f0e8e402412ba5011d15c244103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ec8893e0f7843cf5d783d2f350ef14"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ab9ec8893e0f7843cf5d783d2f350ef14">ssl_private_key_filepath</a></td></tr>
<tr class="separator:ab9ec8893e0f7843cf5d783d2f350ef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8e65c3a059d3b586fafa9ef3282c29"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a4f8e65c3a059d3b586fafa9ef3282c29">ssl_ca_filepath</a></td></tr>
<tr class="separator:a4f8e65c3a059d3b586fafa9ef3282c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1516fd7fed26bfa77c0246ed26c2eb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a3e1516fd7fed26bfa77c0246ed26c2eb">ssl_cipher_list</a></td></tr>
<tr class="separator:a3e1516fd7fed26bfa77c0246ed26c2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef917c0b23976a264d2474901b4f5aa3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#aef917c0b23976a264d2474901b4f5aa3">http_proxy_address</a></td></tr>
<tr class="separator:aef917c0b23976a264d2474901b4f5aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b59f2bdc869871e7bde232db94f5ca6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a7b59f2bdc869871e7bde232db94f5ca6">http_proxy_port</a></td></tr>
<tr class="separator:a7b59f2bdc869871e7bde232db94f5ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9d22437de92c197f3cee52912b2c03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a9c9d22437de92c197f3cee52912b2c03">gid</a></td></tr>
<tr class="separator:a9c9d22437de92c197f3cee52912b2c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac105b4180008cb3e672d57beead8382e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac105b4180008cb3e672d57beead8382e">uid</a></td></tr>
<tr class="separator:ac105b4180008cb3e672d57beead8382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3b17a25e1fbc772f21eb4959a82724"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a9d3b17a25e1fbc772f21eb4959a82724">options</a></td></tr>
<tr class="separator:a9d3b17a25e1fbc772f21eb4959a82724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9d94cdfb893d777b4a4db81e7b5ac0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0e9d94cdfb893d777b4a4db81e7b5ac0">user</a></td></tr>
<tr class="separator:a0e9d94cdfb893d777b4a4db81e7b5ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac583ce92b8e1c949cb6fef6bfe713d56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ac583ce92b8e1c949cb6fef6bfe713d56">ka_time</a></td></tr>
<tr class="separator:ac583ce92b8e1c949cb6fef6bfe713d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baab4285c679fbe027c2504621d7410"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a3baab4285c679fbe027c2504621d7410">ka_probes</a></td></tr>
<tr class="separator:a3baab4285c679fbe027c2504621d7410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381342a398883d6204955ff3c1849ddd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a381342a398883d6204955ff3c1849ddd">ka_interval</a></td></tr>
<tr class="separator:a381342a398883d6204955ff3c1849ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1654d41bea6fb2f619b57e6a264b26a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlws__polarssl__context.html">SSL_CTX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a1654d41bea6fb2f619b57e6a264b26a4">provided_client_ssl_ctx</a></td></tr>
<tr class="separator:a1654d41bea6fb2f619b57e6a264b26a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e790dda6202604f73a03b6149bc12bb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0e790dda6202604f73a03b6149bc12bb">provided_client_ssl_ctx</a></td></tr>
<tr class="separator:a0e790dda6202604f73a03b6149bc12bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdfd3c484689ba6f0f2cc91b38ce948"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0cdfd3c484689ba6f0f2cc91b38ce948">max_http_header_data</a></td></tr>
<tr class="separator:a0cdfd3c484689ba6f0f2cc91b38ce948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b154e79abc1167ba4ac3539f4af6720"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a0b154e79abc1167ba4ac3539f4af6720">max_http_header_pool</a></td></tr>
<tr class="separator:a0b154e79abc1167ba4ac3539f4af6720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52f3237e144e9ddcab5e2cf91d1e419"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ae52f3237e144e9ddcab5e2cf91d1e419">count_threads</a></td></tr>
<tr class="separator:ae52f3237e144e9ddcab5e2cf91d1e419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e63e24c88289e0c8352377ef4d3646"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a45e63e24c88289e0c8352377ef4d3646">fd_limit_per_thread</a></td></tr>
<tr class="separator:a45e63e24c88289e0c8352377ef4d3646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfa3d51df2def3349a5cbf0d712822d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a6cfa3d51df2def3349a5cbf0d712822d">timeout_secs</a></td></tr>
<tr class="separator:a6cfa3d51df2def3349a5cbf0d712822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5d4e7d9f86b58a1c6fac14f0a5f5f9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#afa5d4e7d9f86b58a1c6fac14f0a5f5f9">ecdh_curve</a></td></tr>
<tr class="separator:afa5d4e7d9f86b58a1c6fac14f0a5f5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50db098a208f045f7811207d2bee4b9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ad50db098a208f045f7811207d2bee4b9">vhost_name</a></td></tr>
<tr class="separator:ad50db098a208f045f7811207d2bee4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8122cfc0810bafe51edb3ba6bf9a1251"><td class="memItemLeft" align="right" valign="top">const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a8122cfc0810bafe51edb3ba6bf9a1251">plugin_dirs</a></td></tr>
<tr class="separator:a8122cfc0810bafe51edb3ba6bf9a1251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999866fcd15dbd621773436f97190458"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a999866fcd15dbd621773436f97190458">pvo</a></td></tr>
<tr class="separator:a999866fcd15dbd621773436f97190458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81697c6b763b5ef3ee52862bc70b07d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a81697c6b763b5ef3ee52862bc70b07d6">keepalive_timeout</a></td></tr>
<tr class="separator:a81697c6b763b5ef3ee52862bc70b07d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e95ba721f7bd2b676719f8093c23a2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#ad0e95ba721f7bd2b676719f8093c23a2">log_filepath</a></td></tr>
<tr class="separator:ad0e95ba721f7bd2b676719f8093c23a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ffbb0d010309669611f8c4eda7d7f8"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__http__mount.html">lws_http_mount</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a13ffbb0d010309669611f8c4eda7d7f8">mounts</a></td></tr>
<tr class="separator:a13ffbb0d010309669611f8c4eda7d7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137a9b9de4f6a7993fed8746d551e616"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a137a9b9de4f6a7993fed8746d551e616">server_string</a></td></tr>
<tr class="separator:a137a9b9de4f6a7993fed8746d551e616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f88c0745adbd1d6b9b619b8de30209"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a57f88c0745adbd1d6b9b619b8de30209">pt_serv_buf_size</a></td></tr>
<tr class="separator:a57f88c0745adbd1d6b9b619b8de30209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d9e85e137f35fb006f2e4a53f0887a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#aa8d9e85e137f35fb006f2e4a53f0887a">max_http_header_data2</a></td></tr>
<tr class="separator:aa8d9e85e137f35fb006f2e4a53f0887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704940261951ced6b5d8191bd8b9bb2d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a704940261951ced6b5d8191bd8b9bb2d">ssl_options_set</a></td></tr>
<tr class="separator:a704940261951ced6b5d8191bd8b9bb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0bc0b28cd7d90ab306723d8ffa96fa"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#adb0bc0b28cd7d90ab306723d8ffa96fa">ssl_options_clear</a></td></tr>
<tr class="separator:adb0bc0b28cd7d90ab306723d8ffa96fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a1a25a7df3793f59047e20dd580078"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a33a1a25a7df3793f59047e20dd580078">ws_ping_pong_interval</a></td></tr>
<tr class="separator:a33a1a25a7df3793f59047e20dd580078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca0ec6b8675c13849bbdcdc0d50c9a3"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#a8ca0ec6b8675c13849bbdcdc0d50c9a3">headers</a></td></tr>
<tr class="separator:a8ca0ec6b8675c13849bbdcdc0d50c9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce3b59950eca3203faa07381bbed5d7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html#afce3b59950eca3203faa07381bbed5d7">_unused</a> [8]</td></tr>
<tr class="separator:afce3b59950eca3203faa07381bbed5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> - parameters to create context and /or vhost with</p>
<p>This is also used to create vhosts.... if LWS_SERVER_OPTION_EXPLICIT_VHOSTS is not given, then for backwards compatibility one vhost is created at context-creation time using the info from this struct.</p>
<p>If LWS_SERVER_OPTION_EXPLICIT_VHOSTS is given, then no vhosts are created at the same time as the context, they are expected to be created afterwards. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="afce3b59950eca3203faa07381bbed5d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lws_context_creation_info::_unused[8]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dummy </p>

</div>
</div>
<a class="anchor" id="ae52f3237e144e9ddcab5e2cf91d1e419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::count_threads</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: how many contexts to create in an array, 0 = 1 </p>

</div>
</div>
<a class="anchor" id="afa5d4e7d9f86b58a1c6fac14f0a5f5f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ecdh_curve</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: if NULL, defaults to initializing server with "prime256v1" </p>

</div>
</div>
<a class="anchor" id="a4a3d1155fc52f5048b481884f6fb947c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__extension.html">lws_extension</a>* lws_context_creation_info::extensions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: NULL or array of <a class="el" href="structlws__extension.html">lws_extension</a> structs listing the extensions this context supports. </p>

</div>
</div>
<a class="anchor" id="a45e63e24c88289e0c8352377ef4d3646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::fd_limit_per_thread</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: nonzero means restrict each service thread to this many fds, 0 means the default which is divide the process fd limit by the number of threads. </p>

</div>
</div>
<a class="anchor" id="a9c9d22437de92c197f3cee52912b2c03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::gid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: group id to change to after setting listen socket, or -1. </p>

</div>
</div>
<a class="anchor" id="a8ca0ec6b8675c13849bbdcdc0d50c9a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a>* lws_context_creation_info::headers</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: pointer to optional linked list of per-vhost canned headers that are added to server responses </p>

</div>
</div>
<a class="anchor" id="aef917c0b23976a264d2474901b4f5aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::http_proxy_address</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If non-NULL, attempts to proxy via the given address. If proxy auth is required, use format "username:password\@server:port" </p>

</div>
</div>
<a class="anchor" id="a7b59f2bdc869871e7bde232db94f5ca6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::http_proxy_port</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If http_proxy_address was non-NULL, uses this port </p>

</div>
</div>
<a class="anchor" id="a75434932bb5df54665ea678eb8ac104a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::iface</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: NULL to bind the listen socket to all interfaces, or the interface name, eg, "eth2" If options specifies LWS_SERVER_OPTION_UNIX_SOCK, this member is the pathname of a UNIX domain socket. you can use the UNIX domain sockets in abstract namespace, by prepending an at symbol to the socket name. </p>

</div>
</div>
<a class="anchor" id="a381342a398883d6204955ff3c1849ddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ka_interval</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: if ka_time was nonzero, how long to wait before each ka_probes attempt </p>

</div>
</div>
<a class="anchor" id="a3baab4285c679fbe027c2504621d7410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ka_probes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: if ka_time was nonzero, after the timeout expires how many times to try to get a response from the peer before giving up and killing the connection </p>

</div>
</div>
<a class="anchor" id="ac583ce92b8e1c949cb6fef6bfe713d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::ka_time</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 for no TCP keepalive, otherwise apply this keepalive timeout to all libwebsocket sockets, client or server </p>

</div>
</div>
<a class="anchor" id="a81697c6b763b5ef3ee52862bc70b07d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::keepalive_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: (default = 0 = 60s) seconds to allow remote client to hold on to an idle HTTP/1.1 connection </p>

</div>
</div>
<a class="anchor" id="ad0e95ba721f7bd2b676719f8093c23a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::log_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: filepath to append logs to... this is opened before any dropping of initial privileges </p>

</div>
</div>
<a class="anchor" id="a0cdfd3c484689ba6f0f2cc91b38ce948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short lws_context_creation_info::max_http_header_data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: The max amount of header payload that can be handled in an http request (unrecognized header payload is dropped) </p>

</div>
</div>
<a class="anchor" id="aa8d9e85e137f35fb006f2e4a53f0887a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::max_http_header_data2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: if max_http_header_data is 0 and this is nonzero, this will be used in place of the default. It's like this for compatibility with the original short version, this is unsigned int length. </p>

</div>
</div>
<a class="anchor" id="a0b154e79abc1167ba4ac3539f4af6720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short lws_context_creation_info::max_http_header_pool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: The max number of connections with http headers that can be processed simultaneously (the corresponding memory is allocated for the lifetime of the context). If the pool is busy new incoming connections must wait for accept until one becomes free. </p>

</div>
</div>
<a class="anchor" id="a13ffbb0d010309669611f8c4eda7d7f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__http__mount.html">lws_http_mount</a>* lws_context_creation_info::mounts</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: optional linked list of mounts for this vhost </p>

</div>
</div>
<a class="anchor" id="a9d3b17a25e1fbc772f21eb4959a82724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::options</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST + CONTEXT: 0, or LWS_SERVER_OPTION_... bitfields </p>

</div>
</div>
<a class="anchor" id="a8122cfc0810bafe51edb3ba6bf9a1251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const* lws_context_creation_info::plugin_dirs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: NULL, or NULL-terminated array of directories to scan for lws protocol plugins at context creation time </p>

</div>
</div>
<a class="anchor" id="a424a5ce268d6903e42243be94487ab85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::port</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Port to listen on... you can use CONTEXT_PORT_NO_LISTEN to suppress listening on any port, that's what you want if you are not running a websocket server at all but just using it as a client </p>

</div>
</div>
<a class="anchor" id="abb90ffb3e6d6db2db20f529d61bd9122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a>* lws_context_creation_info::protocols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Array of structures listing supported protocols and a protocol- specific callback for each one. The list is ended with an entry that has a NULL callback pointer. </p>

</div>
</div>
<a class="anchor" id="a1654d41bea6fb2f619b57e6a264b26a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlws__polarssl__context.html">SSL_CTX</a>* lws_context_creation_info::provided_client_ssl_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: If non-null, swap out libwebsockets ssl implementation for the one provided by provided_ssl_ctx. Libwebsockets no longer is responsible for freeing the context if this option is selected. </p>

</div>
</div>
<a class="anchor" id="a0e790dda6202604f73a03b6149bc12bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lws_context_creation_info::provided_client_ssl_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dummy if ssl disabled </p>

</div>
</div>
<a class="anchor" id="a57f88c0745adbd1d6b9b619b8de30209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::pt_serv_buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 = default of 4096. This buffer is used by various service related features including file serving, it defines the max chunk of file that can be sent at once. At the risk of lws having to buffer failed large sends, it can be increased to, eg, 128KiB to improve throughput. </p>

</div>
</div>
<a class="anchor" id="a999866fcd15dbd621773436f97190458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a>* lws_context_creation_info::pvo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: pointer to optional linked list of per-vhost options made accessible to protocols </p>

</div>
</div>
<a class="anchor" id="a137a9b9de4f6a7993fed8746d551e616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::server_string</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: string used in HTTP headers to identify server software, if NULL, "libwebsockets". </p>

</div>
</div>
<a class="anchor" id="a4f8e65c3a059d3b586fafa9ef3282c29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_ca_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: CA certificate filepath or NULL </p>

</div>
</div>
<a class="anchor" id="ac62b0f0e8e402412ba5011d15c244103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_cert_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: If libwebsockets was compiled to use ssl, and you want to listen using SSL, set to the filepath to fetch the server cert from, otherwise NULL for unencrypted </p>

</div>
</div>
<a class="anchor" id="a3e1516fd7fed26bfa77c0246ed26c2eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_cipher_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: List of valid ciphers to use (eg, "RC4-MD5:RC4-SHA:AES128-SHA:AES256-SHA:HIGH:!DSS:!aNULL" or you can leave it as NULL to get "DEFAULT" </p>

</div>
</div>
<a class="anchor" id="adb0bc0b28cd7d90ab306723d8ffa96fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long lws_context_creation_info::ssl_options_clear</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Any bits set here will be cleared as SSL options </p>

</div>
</div>
<a class="anchor" id="a704940261951ced6b5d8191bd8b9bb2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long lws_context_creation_info::ssl_options_set</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: Any bits set here will be set as SSL options </p>

</div>
</div>
<a class="anchor" id="ab9ec8893e0f7843cf5d783d2f350ef14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_private_key_filepath</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: filepath to private key if wanting SSL mode; if this is set to NULL but sll_cert_filepath is set, the OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY callback is called to allow setting of the private key directly via openSSL library calls </p>

</div>
</div>
<a class="anchor" id="af3fb447be15c4fcb01d3285a6678ab54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::ssl_private_key_password</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: NULL or the passphrase needed for the private key </p>

</div>
</div>
<a class="anchor" id="a6cfa3d51df2def3349a5cbf0d712822d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lws_context_creation_info::timeout_secs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: various processes involving network roundtrips in the library are protected from hanging forever by timeouts. If nonzero, this member lets you set the timeout used in seconds. Otherwise a default timeout is used. </p>

</div>
</div>
<a class="anchor" id="ac8a75b7b259a3c3a5fbb4219a3f06c29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a>* lws_context_creation_info::token_limits</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: NULL or struct <a class="el" href="structlws__token__limits.html">lws_token_limits</a> pointer which is initialized with a token length limit for each possible WSI_TOKEN_ </p>

</div>
</div>
<a class="anchor" id="ac105b4180008cb3e672d57beead8382e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lws_context_creation_info::uid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: user id to change to after setting listen socket, or -1. </p>

</div>
</div>
<a class="anchor" id="a0e9d94cdfb893d777b4a4db81e7b5ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lws_context_creation_info::user</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: optional user pointer that can be recovered via the context pointer using lws_context_user </p>

</div>
</div>
<a class="anchor" id="ad50db098a208f045f7811207d2bee4b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lws_context_creation_info::vhost_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VHOST: name of vhost, must match external DNS name used to access the site, like "warmcat.com" as it's used to match Host: header and / or SNI name for SSL. </p>

</div>
</div>
<a class="anchor" id="a33a1a25a7df3793f59047e20dd580078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short lws_context_creation_info::ws_ping_pong_interval</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CONTEXT: 0 for none, else interval in seconds between sending PINGs on idle websocket connections. When the PING is sent, the PONG must come within the normal timeout_secs timeout period or the connection will be dropped. Any RX or TX traffic on the connection restarts the interval timer, so a connection which always sends or receives something at intervals less than the interval given here will never send PINGs / expect PONGs. Conversely as soon as the ws connection is established, an idle connection will do the PING / PONG roundtrip as soon as ws_ping_pong_interval seconds has passed without traffic </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lib/<a class="el" href="libwebsockets_8h_source.html">libwebsockets.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
